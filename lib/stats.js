import seedrandom from "https://esm.sh/seedrandom@3.0.5";

let pyodide;

async function loadPyodide() {
    const pyodideVersion = '0.25.0';
    const pyodideEsmUrl = 'https://cdn.jsdelivr.net/npm/pyodide@' + pyodideVersion + '/+esm';
    const pyodideRootUrl = 'https://cdn.jsdelivr.net/pyodide/v' + pyodideVersion + '/full/';

    if (!pyodide) {
        pyodide = (await import(pyodideEsmUrl)).loadPyodide({indexURL: pyodideRootUrl});
    }

    return pyodide;
}


async function buildDesignMatrix(formula, dataset, dtypes) {
    const pyodide = await loadPyodide();
    await pyodide.loadPackage(['pandas', 'patsy']);

    await pyodide.globals.set("formula", formula);
    await pyodide.globals.set("data", dataset);
    await pyodide.globals.set("dtypes", dtypes);

    const pyCode = `
from collections import OrderedDict
import json

import pandas as pd
from patsy import dmatrix


class DesignInfo:
    """
    A class to mimic the DesignInfo class object generated by Patsy. This object contains the information linking
    the Patsy formula with the design matrix that it generates.
    """
    column_names: list
    column_name_indexes: OrderedDict
    term_names: list
    term_name_slices: OrderedDict
    terms: list
    term_slices: OrderedDict
    term_codings: OrderedDict

    def __init__(self, design_matrix: pd.DataFrame):
        self.column_names = design_matrix.design_info.column_names
        self.column_name_indexes = design_matrix.design_info.column_name_indexes
        self.term_names = design_matrix.design_info.term_names
        self.term_name_slices = design_matrix.design_info.term_name_slices
        self.terms = design_matrix.design_info.terms
        self.term_slices = design_matrix.design_info.term_slices
        self.term_codings = design_matrix.design_info.term_codings


def remove_intercept(design_matrix: pd.DataFrame) -> pd.DataFrame:
    if 'Intercept' not in design_matrix.columns:
        return design_matrix

    intercept_index = design_matrix.columns.get_loc('Intercept')
    design_matrix.pop('Intercept')

    # Update design info to reflect the removal of the intercept term
    design_info = DesignInfo(design_matrix)
    design_info.column_names = [column_name for column_name in design_info.column_names if column_name != 'Intercept']
    design_info.column_name_indexes = OrderedDict(
        [(key, value - 1 if value > intercept_index else value)
         for key, value in design_info.column_name_indexes.items()
         if key != 'Intercept'])
    design_info.term_names = [term_name for term_name in design_info.term_names if term_name != 'Intercept']
    design_info.term_name_slices = OrderedDict(
        [(key, slice(value.start - 1 if value.start > intercept_index else value.start,
                     value.stop - 1 if value.stop > intercept_index else value.stop))
         for key, value in design_info.term_name_slices.items()
         if key != 'Intercept'])
    design_info.terms = [term for term in design_info.terms if len(term.factors) != 0]
    design_info.term_slices = OrderedDict(
        [(key, slice(value.start - 1 if value.start > intercept_index else value.start,
                     value.stop - 1 if value.stop > intercept_index else value.stop))
         for key, value in design_info.term_slices.items()
         if len(key.factors) != 0])
    design_info.term_codings = OrderedDict(
        [(key, value) for key, value in design_info.term_codings.items() if len(key.factors) != 0])

    design_matrix.design_info = design_info

    return design_matrix


def build_design_matrix(formula: str, dataset: pd.DataFrame) -> pd.DataFrame:
    design_matrix = dmatrix(formula, dataset, return_type='dataframe')
    design_matrix = remove_intercept(design_matrix)
    design_matrix.design_info.original_column_names = list(dataset.columns)

    return design_matrix


df = pd.read_json(data, dtype=json.loads(dtypes), orient='split')
design_matrix = build_design_matrix(formula, df)

# Clear memory
del data, formula, dtypes, df

# Return
design_matrix.to_json(orient='split')
        `;

    const designMatrix = await pyodide.runPython(pyCode);

    return JSON.parse(designMatrix);
}


async function fitLogisticRegression({formula, dataset, dtypes, maxiter = 1000}) {
    const pyodide = await loadPyodide();
    await pyodide.loadPackage(['pandas', 'statsmodels']);

    await pyodide.globals.set("formula", formula);
    await pyodide.globals.set("data", dataset);
    await pyodide.globals.set("dtypes", dtypes);
    await pyodide.globals.set("maxiter", maxiter);

    const pyCode = `
import json

import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf


model = smf.logit(formula, data=pd.read_json(data, dtype=json.loads(dtypes))).fit(disp=0, method= 'bfgs', maxiter=maxiter)
print(model.summary())
output = pd.concat([model.params, model.bse, model.conf_int()[0], model.conf_int()[1]], axis=1)
output.columns = ["relativeRisk", "standardError", "lowerCI", "upperCI"]

output.to_json(orient='index')
`;

    const modelOutput = await pyodide.runPython(pyCode);

    return JSON.parse(modelOutput);
}


function sampleWithReplacement(data, n, rng) {
    const sampledData = [];
    for (let i = 0; i < n; i++) {
        const rowIndex = Math.floor(rng() * data.data.length);
        sampledData.push(data.data[rowIndex]);
    }

    return {
        columns: data.columns,
        index: Array.from({length: n}, (_, i) => i),
        data: sampledData
    };
}


function generateCaseControlData(data, outcomeVariableName, nCases, nControls, rng) {
    const outcomeIndex = data.columns.indexOf(outcomeVariableName);
    const casesIndex = [];
    const controlsIndex = [];

    data.data.forEach((row, index) => {
        if (row[outcomeIndex] === 1) casesIndex.push(index);
        if (row[outcomeIndex] === 0) controlsIndex.push(index);
    });

    // JSON split format
    const casesData = { columns: data.columns, index: casesIndex, data: casesIndex.map(i => data.data[i]) };
    const controlsData = { columns: data.columns, index: controlsIndex, data: controlsIndex.map(i => data.data[i]) };

    // Sample with replacement from each group
    const positiveSamples = sampleWithReplacement(casesData, nCases, rng);
    const negativeSamples = sampleWithReplacement(controlsData, nControls, rng);

    // Concatenate the dataset
    const caseControlDataset = {
        columns: data.columns,
        index: [...positiveSamples.index, ...negativeSamples.index.map(i => i + positiveSamples.index.length)],
        data: [...positiveSamples.data, ...negativeSamples.data]
    };

    return shuffleArray(caseControlDataset, rng);
}


function shuffleArray(data, rng) {
    let array = data.index.slice();
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];  // shuffling indices
    }
    // Reorder data based on shuffled indices
    const shuffledData = array.map(index => data.data[data.index.indexOf(index)]);
    return {
        ...data,
        index: array,
        data: shuffledData
    };
}


function calculateLinearScore(coefficients, designMatrix) {
    const columnIndexMap = designMatrix.columns.reduce((acc, col, index) => {
        acc[col] = index;
        return acc;
    }, {});

    return designMatrix.data.map(row => {
        let score = 0;
        for (const key in coefficients) {
            if (key in columnIndexMap) {
                score += coefficients[key] * row[columnIndexMap[key]];
            }
        }
        return score;
    });
}


export {buildDesignMatrix, sampleWithReplacement, generateCaseControlData, calculateLinearScore, fitLogisticRegression};