import seedrandom from "https://esm.sh/seedrandom@3.0.5";

let pyodide;

async function loadPyodide() {
    const pyodideVersion = '0.25.0';
    const pyodideEsmUrl = 'https://cdn.jsdelivr.net/npm/pyodide@' + pyodideVersion + '/+esm';
    const pyodideRootUrl = 'https://cdn.jsdelivr.net/pyodide/v' + pyodideVersion + '/full/';

    if (!pyodide) {
        pyodide = (await import(pyodideEsmUrl)).loadPyodide({indexURL: pyodideRootUrl});
    }

    return pyodide;
}


async function buildDesignMatrix(formula, dataset, dtypes) {
    const pyodide = await loadPyodide();
    await pyodide.loadPackage(['pandas', 'patsy']);

    await pyodide.globals.set("formula", formula);
    await pyodide.globals.set("data", dataset);
    await pyodide.globals.set("dtypes", dtypes);

    const pyCode = `
from collections import OrderedDict
import json

import pandas as pd
from patsy import dmatrix


class DesignInfo:
    """
    A class to mimic the DesignInfo class object generated by Patsy. This object contains the information linking
    the Patsy formula with the design matrix that it generates.
    """
    column_names: list
    column_name_indexes: OrderedDict
    term_names: list
    term_name_slices: OrderedDict
    terms: list
    term_slices: OrderedDict
    term_codings: OrderedDict

    def __init__(self, design_matrix: pd.DataFrame):
        self.column_names = design_matrix.design_info.column_names
        self.column_name_indexes = design_matrix.design_info.column_name_indexes
        self.term_names = design_matrix.design_info.term_names
        self.term_name_slices = design_matrix.design_info.term_name_slices
        self.terms = design_matrix.design_info.terms
        self.term_slices = design_matrix.design_info.term_slices
        self.term_codings = design_matrix.design_info.term_codings


def remove_intercept(design_matrix: pd.DataFrame) -> pd.DataFrame:
    if 'Intercept' not in design_matrix.columns:
        return design_matrix

    intercept_index = design_matrix.columns.get_loc('Intercept')
    design_matrix.pop('Intercept')

    # Update design info to reflect the removal of the intercept term
    design_info = DesignInfo(design_matrix)
    design_info.column_names = [column_name for column_name in design_info.column_names if column_name != 'Intercept']
    design_info.column_name_indexes = OrderedDict(
        [(key, value - 1 if value > intercept_index else value)
         for key, value in design_info.column_name_indexes.items()
         if key != 'Intercept'])
    design_info.term_names = [term_name for term_name in design_info.term_names if term_name != 'Intercept']
    design_info.term_name_slices = OrderedDict(
        [(key, slice(value.start - 1 if value.start > intercept_index else value.start,
                     value.stop - 1 if value.stop > intercept_index else value.stop))
         for key, value in design_info.term_name_slices.items()
         if key != 'Intercept'])
    design_info.terms = [term for term in design_info.terms if len(term.factors) != 0]
    design_info.term_slices = OrderedDict(
        [(key, slice(value.start - 1 if value.start > intercept_index else value.start,
                     value.stop - 1 if value.stop > intercept_index else value.stop))
         for key, value in design_info.term_slices.items()
         if len(key.factors) != 0])
    design_info.term_codings = OrderedDict(
        [(key, value) for key, value in design_info.term_codings.items() if len(key.factors) != 0])

    design_matrix.design_info = design_info

    return design_matrix


def build_design_matrix(formula: str, dataset: pd.DataFrame) -> pd.DataFrame:
    design_matrix = dmatrix(formula, dataset, return_type='dataframe')
    design_matrix = remove_intercept(design_matrix)
    design_matrix.design_info.original_column_names = list(dataset.columns)

    return design_matrix

dtype_dict = json.loads(dtypes)
df = pd.read_json(data, dtype=dtype_dict)
design_matrix = build_design_matrix(formula, df)

design_matrix.to_json(orient='records')
        `;

    const designMatrix = await pyodide.runPython(pyCode);

    return JSON.parse(designMatrix);
}


async function fitLogisticRegression(formula, dataset, dtypes) {
    const pyodide = await loadPyodide();
    await pyodide.loadPackage(['pandas', 'statsmodels']);

    await pyodide.globals.set("formula", formula);
    await pyodide.globals.set("data", dataset);
    await pyodide.globals.set("dtypes", dtypes);

    const pyCode = `
import json

import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf


model = smf.logit(formula, data=pd.read_json(data, dtype=json.loads(dtypes))).fit()
output = pd.concat([model.params, model.bse, model.conf_int()[0], model.conf_int()[1]], axis=1)
output.columns = ["relative_risk", "standard_error", "lower_CI", "upper_CI"]

output.to_json(orient='index')
`;

    const modelOutput = await pyodide.runPython(pyCode);

    return JSON.parse(modelOutput);
}


function sampleWithReplacement(data, n, rng) {
    const sample = [];
    for (let i = 0; i < n; i++) {
        sample.push(data[Math.floor(rng() * data.length)]);
    }
    return sample;
}


function generateCaseControlDataset(data, outcomeVariableName, nCases, nControls, rng) {
    const cases = data.filter(item => item[outcomeVariableName] === 1);
    const controls = data.filter(item => item[outcomeVariableName] === 0);

    // Sample with replacement from each group
    const positiveSamples = sampleWithReplacement(cases, nCases, rng);
    const negativeSamples = sampleWithReplacement(controls, nControls, rng);

    // Concatenate the dataset
    const caseControlDataset = positiveSamples.concat(negativeSamples);

    return shuffleArray(caseControlDataset, rng);
}


function shuffleArray(array, rng) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}


function calculateLinearScore(coefficients, designMatrix) {
    return designMatrix.map(row => {
        let score = 0;
        for (const key in coefficients) {
            if (row.hasOwnProperty(key)) {
                score += coefficients[key] * row[key];
            }
        }
        return score;
    });
}


export {buildDesignMatrix, sampleWithReplacement, generateCaseControlDataset, calculateLinearScore, fitLogisticRegression};