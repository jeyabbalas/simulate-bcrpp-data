import D from "https://esm.sh/seedrandom@3.0.5";
async function b(e) {
  return (await fetch(e)).text();
}
async function y(e) {
  return (await fetch(e)).json();
}
async function O(e) {
  const s = await fetch(e);
  return I(await s.text());
}
function I(e) {
  const s = e.trim().split(`
`), i = s[0].split(","), o = s.slice(1).map((t) => t.split(","));
  return {
    columns: i,
    index: Array.from({ length: o.length }, (t, n) => n),
    data: o
  };
}
function A(e, s) {
  const i = e.data.map((o) => o.map((t, n) => {
    const d = e.columns[n];
    switch (s[d]) {
      case "int":
        return parseInt(t);
      case "float":
        return parseFloat(t);
      case "str":
      default:
        return String(t);
    }
  }));
  return {
    ...e,
    data: i
  };
}
let g;
async function k() {
  const e = "0.25.0", s = "https://cdn.jsdelivr.net/npm/pyodide@" + e + "/+esm", i = "https://cdn.jsdelivr.net/pyodide/v" + e + "/full/";
  return g || (g = (await import(s)).loadPyodide({ indexURL: i })), g;
}
async function F(e, s, i) {
  const o = await k();
  await o.loadPackage(["pandas", "patsy"]), await o.globals.set("formula", e), await o.globals.set("data", s), await o.globals.set("dtypes", i);
  const n = await o.runPython(`
from collections import OrderedDict
import json

import pandas as pd
from patsy import dmatrix


class DesignInfo:
    """
    A class to mimic the DesignInfo class object generated by Patsy. This object contains the information linking
    the Patsy formula with the design matrix that it generates.
    """
    column_names: list
    column_name_indexes: OrderedDict
    term_names: list
    term_name_slices: OrderedDict
    terms: list
    term_slices: OrderedDict
    term_codings: OrderedDict

    def __init__(self, design_matrix: pd.DataFrame):
        self.column_names = design_matrix.design_info.column_names
        self.column_name_indexes = design_matrix.design_info.column_name_indexes
        self.term_names = design_matrix.design_info.term_names
        self.term_name_slices = design_matrix.design_info.term_name_slices
        self.terms = design_matrix.design_info.terms
        self.term_slices = design_matrix.design_info.term_slices
        self.term_codings = design_matrix.design_info.term_codings


def remove_intercept(design_matrix: pd.DataFrame) -> pd.DataFrame:
    if 'Intercept' not in design_matrix.columns:
        return design_matrix

    intercept_index = design_matrix.columns.get_loc('Intercept')
    design_matrix.pop('Intercept')

    # Update design info to reflect the removal of the intercept term
    design_info = DesignInfo(design_matrix)
    design_info.column_names = [column_name for column_name in design_info.column_names if column_name != 'Intercept']
    design_info.column_name_indexes = OrderedDict(
        [(key, value - 1 if value > intercept_index else value)
         for key, value in design_info.column_name_indexes.items()
         if key != 'Intercept'])
    design_info.term_names = [term_name for term_name in design_info.term_names if term_name != 'Intercept']
    design_info.term_name_slices = OrderedDict(
        [(key, slice(value.start - 1 if value.start > intercept_index else value.start,
                     value.stop - 1 if value.stop > intercept_index else value.stop))
         for key, value in design_info.term_name_slices.items()
         if key != 'Intercept'])
    design_info.terms = [term for term in design_info.terms if len(term.factors) != 0]
    design_info.term_slices = OrderedDict(
        [(key, slice(value.start - 1 if value.start > intercept_index else value.start,
                     value.stop - 1 if value.stop > intercept_index else value.stop))
         for key, value in design_info.term_slices.items()
         if len(key.factors) != 0])
    design_info.term_codings = OrderedDict(
        [(key, value) for key, value in design_info.term_codings.items() if len(key.factors) != 0])

    design_matrix.design_info = design_info

    return design_matrix


def build_design_matrix(formula: str, dataset: pd.DataFrame) -> pd.DataFrame:
    design_matrix = dmatrix(formula, dataset, return_type='dataframe')
    design_matrix = remove_intercept(design_matrix)
    design_matrix.design_info.original_column_names = list(dataset.columns)

    return design_matrix


df = pd.read_json(data, dtype=json.loads(dtypes), orient='split')
design_matrix = build_design_matrix(formula, df)

# Clear memory
del data, formula, dtypes, df

# Return
design_matrix.to_json(orient='split')
        `);
  return JSON.parse(n);
}
function x(e, s, i) {
  const o = [];
  for (let t = 0; t < s; t++) {
    const n = Math.floor(i() * e.data.length);
    o.push(e.data[n]);
  }
  return {
    columns: e.columns,
    index: Array.from({ length: s }, (t, n) => n),
    data: o
  };
}
function M(e, s, i, o, t) {
  const n = e.columns.indexOf(s), d = [], r = [];
  e.data.forEach((a, _) => {
    a[n] === 1 && d.push(_), a[n] === 0 && r.push(_);
  });
  const l = { columns: e.columns, index: d, data: d.map((a) => e.data[a]) }, u = { columns: e.columns, index: r, data: r.map((a) => e.data[a]) }, c = x(l, i, t), f = x(u, o, t), p = {
    columns: e.columns,
    index: [...c.index, ...f.index.map((a) => a + c.index.length)],
    data: [...c.data, ...f.data]
  };
  return j(p, t);
}
function j(e, s) {
  let i = e.index.slice();
  for (let t = i.length - 1; t > 0; t--) {
    const n = Math.floor(s() * (t + 1));
    [i[t], i[n]] = [i[n], i[t]];
  }
  const o = i.map((t) => e.data[e.index.indexOf(t)]);
  return {
    ...e,
    index: i,
    data: o
  };
}
function E(e, s) {
  const i = s.columns.reduce((o, t, n) => (o[t] = n, o), {});
  return s.data.map((o) => {
    let t = 0;
    for (const n in e)
      n in i && (t += e[n] * o[i[n]]);
    return t;
  });
}
async function R({ n: e, caseControl: s = !1, caseProportion: i = 0.5, seed: o = 1234 }) {
  const t = D(o), n = {
    lowestEntryAge: 50,
    highestEntryAge: 67,
    lowestFollowup: 5,
    highestFollowup: 13,
    weibullGamma: 2.39,
    weibullLambda: 5e-6,
    proportionPositive: 0.035
  }, d = s ? U(Math.round(e * i), n.proportionPositive) : e, r = "https://raw.githubusercontent.com/jeyabbalas/simulate-bcrpp-data/main/data/bpc3/", l = r + "reference_covariate_data.csv", u = r + "model_formula.txt", c = r + "dtypes.json", f = r + "model_log_odds_ratios.json", p = await b(u), a = await y(c), _ = A(await O(l), a), h = await y(f);
  let m = x(_, d, t);
  m = P(
    m,
    n.lowestEntryAge,
    n.highestEntryAge,
    n.lowestFollowup,
    n.highestFollowup,
    t
  );
  const v = await F(p, JSON.stringify(m), JSON.stringify(a)), w = E(h, v).map(Math.exp);
  return m = S(
    m,
    n.weibullGamma,
    n.weibullLambda,
    w,
    t
  ), m = s ? M(m, "observed_outcome", Math.round(e * i), e - Math.round(e * i), t) : m, m;
}
function P(e, s, i, o, t, n) {
  return {
    columns: [...e.columns, "study_entry_age", "study_exit_age", "observed_followup"],
    index: e.index,
    data: e.data.map((d) => {
      const r = Math.floor(n() * (i - s + 1)) + s, l = Math.floor(n() * (t - o + 1)) + o, u = r + l;
      return [...d, r, u, l];
    })
  };
}
function S(e, s, i, o, t) {
  const n = e.columns.indexOf("study_entry_age"), d = e.columns.indexOf("study_exit_age"), r = e.columns.indexOf("observed_followup");
  return {
    columns: [...e.columns, "time_of_onset", "observed_outcome"],
    index: e.index,
    data: e.data.map((l, u) => {
      const c = l[n], f = l[d], p = l[r];
      let a = Math.pow(
        Math.pow(c, s) - Math.log(t()) / (i * o[u]),
        1 / s
      );
      const _ = a <= f ? 1 : 0;
      return a = +(a - c).toFixed(2), a > p && (a = 1 / 0), [...l, a, _];
    })
  };
}
function U(e, s) {
  return Math.round(e / s);
}
export {
  R as generateSimulatedBPC3Data
};
